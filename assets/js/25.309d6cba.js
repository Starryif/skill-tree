(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{237:function(t,e,a){"use strict";a.r(e);var r=a(0),v=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"html-调试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html-调试","aria-hidden":"true"}},[t._v("#")]),t._v(" HTML 调试")]),t._v(" "),a("p",[t._v("调试其实没有那么可怕，写代码和调试的关键其实是：熟悉语言本身和相关工具。")]),t._v(" "),a("h2",{attrs:{id:"html-和调试-html-和调试"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html-和调试-html-和调试","aria-hidden":"true"}},[t._v("#")]),t._v(" HTML 和调试 {#HTML_和调试}")]),t._v(" "),a("p",[t._v("HTML 并不像 Rust 那么难以理解，浏览器并不会将 HTML 编译成其它形式，而是直接解析并显示结果（称之为解释，而非编译）。可以说 HTML 的 元素 语法比 Rust、JavaScript 或 Python 这样“真正的编程语言”更容易理解。浏览器解析 HTML 的过程比编程语言的编译运行的过程要宽松得多，但这是一把双刃剑。")]),t._v(" "),a("h3",{attrs:{id:"宽松的代码-宽松的代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宽松的代码-宽松的代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 宽松的代码 {#宽松的代码}")]),t._v(" "),a("p",[t._v("宽松是什么意思呢？通常写错代码会带来以下两种主要类型的错误：")]),t._v(" "),a("p",[a("strong",[t._v("语法错误")]),t._v("：由于拼写错误导致程序无法运行，就像上面的 Rust 示例。通常熟悉语法并理解错误信息后很容易修复。")]),t._v(" "),a("p",[a("strong",[t._v("逻辑错误")]),t._v("：不存在语法错误，但代码无法按预期运行。通常逻辑错误比语法错误更难修复，因为无法得到指向错误源头的信息。")]),t._v(" "),a("p",[t._v("HTML 本身不容易出现语法错误，因为浏览器是以宽松模式运行的，这意味着即使出现语法错误浏览器依然会继续运行。"),a("strong",[t._v("浏览器通常都有内建规则来解析书写错误的标记")]),t._v("，所以即使与预期不符，页面仍可显示出来。当然，是存在隐患的。")]),t._v(" "),a("p",[t._v("HTML 之所以以宽松的方式进行解析，是因为 Web 创建的初心就是：人人可发布内容，不去纠结代码语法。如果 Web 以严格的风格起步，也许就不会像今天这样流行了。")]),t._v(" "),a("h3",{attrs:{id:"html-验证-html-验证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html-验证-html-验证","aria-hidden":"true"}},[t._v("#")]),t._v(" HTML 验证 {#HTML_验证}")]),t._v(" "),a("p",[t._v("最好的方法就是让你的HTML页面通过 Markup Validation Service。由 W3C（制定 HTML、CSS 和其他网络技术标准的组织） 创立并维护的"),a("strong",[t._v("标记验证服务")]),t._v("。把一个 HTML 文档加载至本网页并运行 ，网页会返回一个错误报告。")]),t._v(" "),a("p",[t._v("网页可以接受网址、上传一个 HTML 文档，或者直接输入一些 HTML 代码。")]),t._v(" "),a("h3",{attrs:{id:"错误信息分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误信息分析","aria-hidden":"true"}},[t._v("#")]),t._v(" 错误信息分析")]),t._v(" "),a("p",[t._v("错误信息一般都是有用的，也有没用的，有一些经验后你就能够分析并修复这些错误。下面来观察这些错误信息。可以看到每条信息都对应一个行号和一条信息，使得定位错误更方便。")]),t._v(" "),a("p",[t._v("End tag li implied, but there were open elements（需要 li 的结束标签，但又开始了新的元素）（共出现 2 次）：这条信息表明有开始标签必须有结束标签，必须出现结束标签的地方却没有找到它。行/列信息指出结束标签必须出现的位置的第一行，这一线索已经足够明显了。")]),t._v(" "),a("p",[t._v("Unclosed element strong（未闭合元素 strong ）：非常容易理解，<strong> 元素没有闭合，行/列信息表明了它的位置。")]),t._v(" "),a("p",[t._v("End tag strong violates nesting rules（结束标签 strong 违反了嵌套规则）：指出了错误嵌套的元素，行/列信息表明了它的位置。")]),t._v(" "),a("p",[t._v("End of file reached when inside an attribute value. Ignoring tag（在属性值内达到文件末尾。忽略标签）: 这个比较难懂，它说的是在某个地方有一个属性的值格式有误，估计是在文件末尾附近，因为文件的结尾出现在了一个属性值里。事实上浏览器没有渲染超链接已经是一个很明显的线索了。")]),t._v(" "),a("p",[t._v("End of file seen and there were open elements（文件结尾有未闭合的元素）：这个略有歧义，但基本上表明了有元素没有正确闭合。行号指向文件最后几行，且错误信息给出了一个这种错误的案例：")]),t._v(" "),a("p",[t._v('来看一个示例：<a href="https://www.mozilla.org/>Mozilla 主页链接</a> ↩ </ul>↩ </body>↩</html>')]),t._v(" "),a("p",[t._v("注：属性缺少结束引号会导致元素无法闭合。因为文档所有剩余部分（直到文档某处出现一个引号）都将被解析为属性的内容。")]),t._v(" "),a("p",[t._v("Unclosed element ul（未闭合元素 ul）：这个意义不大，因为 <ul> 已经正确闭合了。出现这个错误是因为 <a> 元素没有右引号而没有闭合。")]),t._v(" "),a("p",[t._v("如果你不能一次弄懂所有的错误，别着急，可以试试先修复那些已经弄懂的，再申请验证，看看剩下哪些错误。有时候先修复的错误可能让你摆脱后面一系列的错误，因为一个小问题可能引发一连串错误，就像多米诺骨牌。")]),t._v(" "),a("p",[t._v("所有错误都修复之后会得到以下输出：")]),t._v(" "),a("p",[a("strong",[t._v("Document checking completed.No errors or warnings to show.")])])])}],!1,null,null,null);e.default=v.exports}}]);