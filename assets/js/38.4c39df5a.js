(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{214:function(e,_,v){"use strict";v.r(_);var a=v(0),t=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"如何构造html表单"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何构造html表单","aria-hidden":"true"}},[e._v("#")]),e._v(" 如何构造HTML表单")]),e._v(" "),v("p",[e._v("HTML表单的灵活性使它们成为HTML中最复杂的结构之一;您可以使用专用的表单元素和属性构建任何类型的基本表单。在构建HTML表单时使用正确的结构将有助于确保表单"),v("strong",[e._v("可用性")]),e._v("和"),v("strong",[e._v("可访问性")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"form-元素-元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#form-元素-元素","aria-hidden":"true"}},[e._v("#")]),e._v(" <form> 元素 {#"),v("form",[e._v("_元素}")])]),e._v(" "),v("p",[e._v("<form> 元素按照一定的格式定义了表单和确定表单行为的属性。当您想要创建一个HTML表单时，都必须从这个元素开始，然后把所有内容都放在里面。许多辅助技术或浏览器插件可以发现<form>元素并实现特殊的钩子，使它们更易于使用。")]),e._v(" "),v("p",[e._v("注意: 严格禁止在一个表单内嵌套另一个表单。嵌套会使表单的行为不可预知，而这取决于正在使用的浏览器。")]),e._v(" "),v("p",[e._v("请注意，在<form>元素之外使用表单小部件是可能的，但是如果您这样做了，那么表单小部件与任何表单都没有任何关系。这样的小部件可以在表单之外使用，但是您应该对于这些小部件有特别的计划，因为它们自己什么也不做。您将不得不使用JavaScript定制他们的行为。")]),e._v(" "),v("p",[e._v("注意: HTML5在HTML表单元素中引入form属性。它让您显式地将元素与表单绑定在一起，即使元素不在<form>中。不幸的是，就目前而言，跨浏览器对这个特性的实现还不足以使用。")]),e._v(" "),v("h2",{attrs:{id:"fieldset-和-legend-元素-和-元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fieldset-和-legend-元素-和-元素","aria-hidden":"true"}},[e._v("#")]),e._v(" <fieldset> 和 <legend> 元素 {#"),v("fieldset",[v("em",[e._v("和")]),v("legend",[e._v("_元素}")])])]),e._v(" "),v("p",[e._v("<fieldset>元素是一种方便的用于创建具有相同目的的小部件组的方式，出于样式和语义目的。 你可以在<fieldset>开口标签后加上一个 <legend>元素来给<fieldset> 标上标签。 <legend>的文本内容正式地描述<fieldset>的用途。它是包含在<fieldset>里的。")]),e._v(" "),v("p",[e._v("许多辅助技术将使用<legend> 元素，就好像它是相应的 <fieldset> 元素。例如，在说出每个小部件的标签之前，像Jaws或NVDA这样的屏幕阅读器会说出图例的内容。")]),e._v(" "),v("p",[v("code",[e._v("<form>")])]),e._v(" "),v("p",[v("code",[e._v("<fieldset>")])]),e._v(" "),v("p",[v("code",[e._v("<legend>Fruit juice size</legend>")])]),e._v(" "),v("p",[v("code",[e._v("<p>")])]),e._v(" "),v("p",[v("code",[e._v('<input type="radio" name="size" id="size_1" value="small">')])]),e._v(" "),v("p",[v("code",[e._v('<label for="size_1">Small</label>')])]),e._v(" "),v("p",[v("code",[e._v("</p>")])]),e._v(" "),v("p",[v("code",[e._v("<p>")])]),e._v(" "),v("p",[v("code",[e._v('<input type="radio" name="size" id="size_2" value="medium">')])]),e._v(" "),v("p",[v("code",[e._v('<label for="size_2">Medium</label>')])]),e._v(" "),v("p",[v("code",[e._v("</p>")])]),e._v(" "),v("p",[v("code",[e._v("<p>")])]),e._v(" "),v("p",[v("code",[e._v('<input type="radio" name="size" id="size_3" value="large">')])]),e._v(" "),v("p",[v("code",[e._v('<label for="size_3">Large</label>')])]),e._v(" "),v("p",[v("code",[e._v("</p>")])]),e._v(" "),v("p",[v("code",[e._v("</fieldset>")])]),e._v(" "),v("p",[v("code",[e._v("</form>")])]),e._v(" "),v("p",[e._v("当阅读上述表格时，屏幕阅读器将会读第一个小部件“Fruit juice size small”，“Fruit juice size medium”为第二个，“Fruit juice size large”为第三个。")]),e._v(" "),v("p",[e._v("**每当您有一组单选按钮时，您应该将它们嵌套在<fieldset>元素中。**还有其他用例，一般来说，<fieldset>元素也可以用来对表单进行分段。理想情况下，长表单应该在多个页面之间进行拆分，但是如果表单很长，但必须在单个页面上，那么在不同的fieldsets中放置不同的相关部分可以提高可用性。")]),e._v(" "),v("p",[e._v("因为它对辅助技术的影响， <fieldset> 元素是构建可访问表单的关键元素之一。然而，你有责任不去滥用它。如果可能，每次构建表单时，尝试侦听屏幕阅读器如何解释它。如果听起来很奇怪，试着改进表单结构。")]),e._v(" "),v("h2",{attrs:{id:"label-元素-元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#label-元素-元素","aria-hidden":"true"}},[e._v("#")]),e._v(" <label> 元素 {#"),v("label",[e._v("_元素}")])]),e._v(" "),v("p",[e._v("<label> 元素是为HTML表单小部件定义标签的正式方法。如果你想构建可访问的表单，这是最重要的元素——当正确实现时，屏幕阅读器将会与任何相关的说明一起使用表单元素的标签。")]),e._v(" "),v("p",[v("code",[e._v('<label for="name">Name:</label> <input type="text" id="name" name="user_name">')])]),e._v(" "),v("p",[e._v("通过他们各自的for 属性和 id 属性，<label> 标签与 <input> 正确相关联。如此，一个屏幕阅读器会读出诸如“Name, edit text”之类的东西。")]),e._v(" "),v("p",[e._v("如果标签没有正确设置，屏幕阅读器只会读出Edit text blank”之类的东西，这不太有帮助。")]),e._v(" "),v("p",[e._v("注意，一个小部件可以嵌套在它的<label>元素中，就像这样：")]),e._v(" "),v("p",[v("code",[e._v('<label for="name">')])]),e._v(" "),v("p",[v("code",[e._v('Name: <input type="text" id="name" name="user_name">')])]),e._v(" "),v("p",[v("code",[e._v("</label>")])]),e._v(" "),v("p",[e._v("尽管可以这样做，但人们认为设置for属性才是最好的做法，因为一些辅助技术不理解标签和小部件之间的隐式关系。")]),e._v(" "),v("h3",{attrs:{id:"标签也可点击-标签也可点击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标签也可点击-标签也可点击","aria-hidden":"true"}},[e._v("#")]),e._v(" 标签也可点击! {#标签也可点击!}")]),e._v(" "),v("p",[e._v("正确设置标签的另一个好处是可以在所有浏览器中单击标签来激活相应的小部件。这对于像文本输入这样的例子很有用，在这里你可以点击标签和输入来聚焦它，它同样对于单选按钮和复选框特别有用——这种控件的可点击区域可能非常小，设置标签来使它们可点击区域变大是非常有用的。")]),e._v(" "),v("p",[v("code",[e._v("<form>")])]),e._v(" "),v("p",[v("code",[e._v("<p>")])]),e._v(" "),v("p",[v("code",[e._v('<label for="taste_1">I like cherry</label>')])]),e._v(" "),v("p",[v("code",[e._v('<input type="checkbox" id="taste_1" name="taste_cherry" value="1">')])]),e._v(" "),v("p",[v("code",[e._v("</p>")])]),e._v(" "),v("p",[v("code",[e._v("<p>")])]),e._v(" "),v("p",[v("code",[e._v('<label for="taste_2">I like banana</label>')])]),e._v(" "),v("p",[v("code",[e._v('<input type="checkbox" id="taste_2" name="taste_banana" value="2">')])]),e._v(" "),v("p",[v("code",[e._v("</p>")])]),e._v(" "),v("p",[v("code",[e._v("</form>")])]),e._v(" "),v("h3",{attrs:{id:"多个标签-多个标签"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多个标签-多个标签","aria-hidden":"true"}},[e._v("#")]),e._v(" 多个标签 {#多个标签}")]),e._v(" "),v("p",[e._v("严格地说，您可以在一个小部件上放置多个标签，但是这不是一个好主意，因为一些辅助技术可能难以处理它们。在多个标签的情况下，您应该将一个小部件和它的标签嵌套在一个<label>元素中。")]),e._v(" "),v("p",[v("code",[e._v('<p>Required fields are followed by <abbr title="required">*</abbr>.</p>')])]),e._v(" "),v("p",[v("code")]),e._v(" "),v("p",[v("code",[e._v("\x3c!-- So this: --\x3e")])]),e._v(" "),v("p",[v("code",[e._v("<div>")])]),e._v(" "),v("p",[v("code",[e._v('<label for="username">Name:</label>')])]),e._v(" "),v("p",[v("code",[e._v('<input type="text" name="username">')])]),e._v(" "),v("p",[v("code",[e._v('<label for="username"><abbr title="required">*</abbr></label>')])]),e._v(" "),v("p",[v("code",[e._v("</div>")])]),e._v(" "),v("p",[v("code")]),e._v(" "),v("p",[v("code",[e._v("\x3c!-- would be better done like this: --\x3e")])]),e._v(" "),v("p",[v("code",[e._v("<div>")])]),e._v(" "),v("p",[v("code",[e._v('<label for="username">')])]),e._v(" "),v("p",[v("code",[e._v("<span>Name:</span>")])]),e._v(" "),v("p",[v("code",[e._v('<input id="username" type="text" name="username">')])]),e._v(" "),v("p",[v("code",[e._v('<abbr title="required">*</abbr>')])]),e._v(" "),v("p",[v("code",[e._v("</label>")])]),e._v(" "),v("p",[v("code",[e._v("</div>")])]),e._v(" "),v("p",[v("code")]),e._v(" "),v("p",[v("code",[e._v("\x3c!-- But this is probably best: --\x3e")])]),e._v(" "),v("p",[v("code",[e._v("<div>")])]),e._v(" "),v("p",[v("code",[e._v('<label for="username">Name: <abbr title="required">*</abbr></label>')])]),e._v(" "),v("p",[v("code",[e._v('<input id="username" type="text" name="username">')])]),e._v(" "),v("p",[v("code",[e._v("</div>")])]),e._v(" "),v("p",[e._v("顶部的段落定义了所需元素的规则。它必须在开始时确保像屏幕阅读器这样的辅助技术在用户找到必需的元素之前显示或念出它们。这样，他们就知道星号是什么意思了。根据屏幕阅读器的设置，屏幕阅读器会把星号读为“star”或“required”——不管怎样，都会在第一段中讲清楚。")]),e._v(" "),v("ul",[v("li",[e._v("在第一个例子中，标签根本没有和input一起被念出来——读出来的只是“edit the blank”，和单独被念出的标签。多个<label>元素会使屏幕阅读器迷惑。")]),e._v(" "),v("li",[e._v("在第二个例子中，事情变得清晰一点了——标签和输入一起，读出的是“name star name edit text”，但标签仍然是单独读出的。这还是有点令人困惑，但这次还是稍微好一点了，因为input和label联系起来了。")]),e._v(" "),v("li",[e._v("第三个例子是最好的——标签是一起读出的，标签和输入读出的是“name star edit text”。")])]),e._v(" "),v("p",[e._v("注意：你可能会得到一些不同的结果，这取决于你的屏幕阅读器。这是在VoiceOver上测试的（NVDA的行为也类似）。")]),e._v(" "),v("p",[e._v("注意：不要运行2个或3个未注释版本的示例—— 如果您有多个标签和多个输入相同的ID，那么屏幕阅读器肯定会感到困惑！")]),e._v(" "),v("h2",{attrs:{id:"用于表单的通用html结构-用于表单的通用html结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用于表单的通用html结构-用于表单的通用html结构","aria-hidden":"true"}},[e._v("#")]),e._v(" 用于表单的通用HTML结构 {#用于表单的通用HTML结构}")]),e._v(" "),v("p",[e._v("除了特定于HTML表单的结构之外，还应该记住表单同样是HTML。这意味着您可以使用HTML的所有强大功能来构造一个HTML表单。")]),e._v(" "),v("p",[e._v("用<div>元素包装标签和它的小部件是很常见的做法。<p>元素也经常被使用，HTML列表也是如此（后者在构造多个复选框或单选按钮时最为常见）。")]),e._v(" "),v("p",[e._v("除了<fieldset>元素之外，使用HTML标题（例如，<h1>、<h2>）和分段（如<section>）来构造一个复杂的表单也是一种常见的做法。")]),e._v(" "),v("p",[e._v("最重要的是，你要找到一种你觉得很舒服的风格，而且它也能带来可访问的、可用的形式。")]),e._v(" "),v("p",[e._v("它包含了<section>元素中包含的每个单独的功能部分，以及一个<fieldset>来包含单选按钮。")])])}],!1,null,null,null);_.default=t.exports}}]);